<?php

/**
 * Bootstrap class.
 *
 * @author Stephen Riesenberg
 */
class Bootstrap {
	private static $instance = null;
	
	/*
	 * Holds a cache of class paths, keyed by className.
	 */
	private $paths = array();
	
	/*
	 * Flag to indicate framework has already been initialized.
	 */
	private $initialized = false;
	
	/**
	 * Constructor.
	 */
	private function __construct() {
		
	}
	
	/**
	 * Singleton.
	 * 
	 * @return object
	 */
	public static function getInstance() {
		if (self::$instance == null) {
			self::$instance = new Bootstrap();
		}
		
		return self::$instance;
	}
	
	/**
	 * Bootstrap the framework, executing necessary startup code.
	 *
	 */
	public function initialize() {
		if ($this->initialized) {
			throw new Exception('Framework already initialized.');
		}
		
		if (!defined('ROOT_DIR')) {
			throw new Exception('ROOT_DIR is not defined.');
		}
		
		// set initialized flag
		$this->initialized = true;
		
		// get current path
		$path = realpath(dirname(__file__));
		
		// set default include path
		set_include_path(get_include_path().PATH_SEPARATOR.ROOT_DIR);
		
		// include default helper
		require_once($path.'/lib/helper/default.php');
		
		// cache class paths
		if (IS_DEBUG || !$this->hasCache('classes', ROOT_DIR.'/cache')) {
			// cache root directories
			$paths = array();
			foreach (array('lib', 'ext', 'model', 'apps') as $dir) {
				$this->addPaths(ROOT_DIR.'/'.$dir, $paths);
			}
			
			// check current path
			if (ROOT_DIR != $path) {
				// set default include path
				set_include_path(get_include_path().PATH_SEPARATOR.$path);
				
				// cache local directories
				foreach (array('lib', 'ext', 'apps') as $dir) {
					$this->addPaths($path.'/'.$dir, $paths);
				}
			}
		} else {
			$paths = $this->getCache('classes', ROOT_DIR.'/cache');
		}
		
		$this->paths = $paths;
	}
	
	/**
	 * Automatically determine a class's path.
	 *
	 * @param string className
	 * @return string
	 */
	public function getClassPath($className) {
		return isset($this->paths[$className]) ? $this->paths[$className] : null;
	}
	
	/**
	 * Search a directory recursively, to build an array of class names to class paths.
	 * Searches for classes in the form of [className].class.php.
	 *
	 * @param string dir
	 * @param array paths
	 */
	private function addPaths($dir, &$paths = array()) {
		$handle = opendir($dir);
		while (($file = readdir($handle)) !== false) {
			if ($file == '.' || $file == '..' || $file == '.svn') {
				continue;
			}
			
			if (is_dir($dir.'/'.$file)) {
				// recursively process sub-directories
				$this->addPaths($dir.'/'.$file, $paths);
			} else if (strpos($file, '.class.php') !== false) {
				// remove ".class.php" and cache result
				$className = str_replace('.class.php', '', $file);
				$paths[$className] = $dir;
			}
		}
		
		closedir($handle);
	}
	
	/**
	 * Simple array cache, will write an array to a php cache file.
	 *
	 * @param string name
	 * @param string path
	 * @param array arr
	 */
	private function setCache($name, $path, $arr) {
		$file = $name.'.php';
		$data = array();
		$data[] = '<?php';
		$data[] = '// auto-generated by bootstrap.php';
		$data[] = sprintf('// %s', date('Y-m-d H:i:s'));
		$data[] = '';
		$data[] = sprintf('return %s;', var_export($arr, true));
		$data[] = '';
		$data[] = '?>';
		
		$current_umask = umask();
		@umask(0000);
		
		// create directory structure if needed
		if (!is_dir($path)) {
			@mkdir($path, 0775, true);
		}
		
		if (($fp = @fopen($path.'/'.$file, 'wb')) === false) {
			throw new Exception(sprintf('Unable to write cache file "%s".', $path.'/'.$file));
		}
		
		@flock($fp, LOCK_EX);
		@fwrite($fp, implode("\n", $data));
		@flock($fp, LOCK_UN);
		@fclose($fp);
		
		// change file mode
		@chmod($path.'/'.$file, 0775);
		@umask($current_umask);
	}
	
	/**
	 * Simple array cache, will execute a cache file as php, and return the results.
	 *
	 * @param string name
	 * @param string path
	 * @return array
	 */
	private function getCache($name, $path) {
		$data = include($path.'/'.$name.'.php');
		
		return $data;
	}
	
	/**
	 * Simple array cache, will determine if cache file exists.
	 *
	 * @param string name
	 * @param string path
	 * @return boolean
	 */
	private function hasCache($name, $path) {
		return file_exists($path.'/'.$name.'.php');
	}
}

/**
 * Extend the class loading functionality in php.
 *
 * @param string className
 */
function __autoload($className) {
	$classPath = Bootstrap::getInstance()->getClassPath($className);
	if ($classPath != null) {
		require_once($classPath.'/'.$className.'.class.php');
	}
}

Bootstrap::getInstance()->initialize();

?>
